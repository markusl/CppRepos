<!DOCTYPE html>
<html class="no-js" lang="en"> 
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>C++11 new features</title>    
    <meta name="description" content="">
    <meta name="viewport" content="width=1024, user-scalable=no">

    <!-- Core and extension CSS files -->
    <link rel="stylesheet" href="css/deck.core.css">
    <link rel="stylesheet" href="css/deck.goto.css">
    <link rel="stylesheet" href="css/deck.menu.css">
    <link rel="stylesheet" href="css/deck.navigation.css">
    <link rel="stylesheet" href="css/deck.status.css">
    <link rel="stylesheet" href="css/deck.hash.css">
    
    <link href="js/css" rel="stylesheet" type="text/css.css">        
    <link href="js/css(1)" rel="stylesheet" type="text/css">

    <!-- Theme CSS files -->
    <link rel="stylesheet" id="style-theme-link" href="css/swiss.css">
    <link rel="stylesheet" id="transition-theme-link" href="css/horizontal-slide.css">
    
    <script src="js/modernizr.custom.js"></script><style type="text/css"></style>
    <link type="text/css" rel="stylesheet" href="css/shCoreDefault.css">
    
    <!-- Custom CSS just for this page -->        
    <link rel="stylesheet" href="css/tekla.css"> 
</head>
<body class="deck-container">

<section class="slide">
    <h1>C++11 new features</h1>
    <div class="title-page">
        <p></p>
        <table width="100%">
          <colgroup>
            <col width="1*">
            <col width="1*">
          </colgroup>
        <tbody>
            <tr><td>
            Markus Lindqvist<br>
            19.3.2014<br>
            <a href="http://tekla.com">Tekla</a></td>
            <td><p align="right">
            markus.lindqvist@tekla.com<br>
            </p></td></tr>
            </tbody>
        </table>
    </div>
</section>

<section class="slide">
    <h2>Content</h2>
    <ul>
        <li><h5>Introduction to C++ history</h5></li>
    </ul>
    <ul>
        <li><h5>New features of C++11 in VS2013</h5>
            <ul>
                <li>Uniform initialization</li>
                <li>Range-based for</li>
                <li>Enum class</li>
                <li>Delegating constructor</li>
                <li>final, override, default, delete</li>
                <li>STL algorithms</li>
            </ul>
        </li>
        <li><h5>Modern C++ (VS2010/VS2012)</h5>
            <ul>
                <li>auto</li>
                <li>Pointer usage</li>
                <li>Algorithm usage</li>
            </ul>
        </li>
    </ul>
</section>

<!-- next slide -->
<section class="slide">
    <h2>C++ history</h2>
    <table style="width: 100%">
        <colgroup>
            <col width="50%" /><col width="50%" />
        </colgroup>
        <tr>
        <td valign="top"><!-- Other input -->
            <ul>
                <li>1979 - "C with Classes"</li>
                <li>1983 - Language named to "C++"</li>
                <li>1998 - C++98 (ISO/IEC 14882:1998)</li>
                <li>2003 - C++03 (ISO/IEC 14882:2003)</li>
                <li>2007 - C++TR1 (ISO/IEC TR 19768:2007)</li>
                <li><strong>2011 - C++11 (ISO/IEC 14882:2011)</strong></li>
                <li>201x - C++14</li>
                <li>201x - C++17</li>
            </ul>
        </td>
        <td valign="top"><!-- Other input -->
            <img src="img/cpp_evolution.jpg" alt="" />
        </td>
    </table>
    <a href="http://isocpp.org/std/status">http://isocpp.org/std/status</a>
</section>

<!-- next slide -->
<section class="slide">
    <h2>Visual Studio C++11/C++14 support</h2>
    <img src="img/Updated_Conformance_Map.png" alt="" />
    <a href="http://blogs.msdn.com/b/vcblog/archive/2013/11/18/announcing-the-visual-c-compiler-november-2013-ctp.aspx">Announcing the Visual C++ Compiler November 2013 CTP</a>
</section>

<!-- next slide -->
<section class="slide">
    <h1>New features of C++11 in VS2013</h1>
</section>

<!-- next slide -->
<section class="slide">
    <h2>Uniform initialization 1/2</h2>
    <h5>The C++11 solution is to allow {}-initializer lists for <em>all</em> initialization</h5>
    <pre class="brush: c++">
        X x1 = X{1,2}; 
        X x2 = {1,2};   // the = is optional
        X x3{1,2}; 
        X* p = new X{1,2}; 

        struct D : X {
            D(int x, int y) :X{x,y}
            { /* ... */ };
        };

        struct S {
            int a[3];
            S(int x, int y, int z) :a{x,y,z} // solution to old problem
            { /* ... */ };
        };
    </pre>
    <h6>Copy-construction</h6>
    <pre class="brush: c++">
        X x{a}; 
        X* p = new X{a};
        z = X{a};         // use as cast
        f({a});           // function argument (of type X)
        return {a};       // function return value (function returning X)
    </pre>
    <a href="http://www.stroustrup.com/C++11FAQ.html#uniform-init">Source</a>
</section>
<section class="slide">
    <h2>Uniform initialization 2/2</h2>
    <h5>Return values</h5>
    <pre class="brush: c++">
        virtual std::array&lt;double, 6&gt; GetOffsets() const
        {
            return{ m_Struct.OffsetXMin, m_Struct.OffsetXMax, m_Struct.OffsetYMin,
                    m_Struct.OffsetYMax, m_Struct.OffsetZMin, m_Struct.OffsetZMax };
        }
        virtual Vector_c GetReferenceSize() const
        {
            return{ m_Struct.ReferenceSizeX, m_Struct.ReferenceSizeY, m_Struct.ReferenceSizeZ };
        }
    </pre>
    <h5>Function parameters</h5>
    <pre class="brush: c++">
    geometry::IndirectPolygon_t CreateIndirectPolygon(const std::array&lt;int, 4&gt; &aIndices)
    {
        return{ aIndices.begin(), aIndices.end() };
    }
    
    const auto IndirectPolygon = CreateIndirectPolygon({ { 0, 1, 2, 3 } });
    </pre>
    <a href="http://www.stroustrup.com/C++11FAQ.html#uniform-init">Source</a>
</section>
<!-- next slide -->
<section class="slide">
    <h2>Range-based for loop</h2>
    <h5>C++98</h5>
    <pre class="brush: c++">
    for(vector&lt;int&gt;::iterator it = Container.begin(); it != Container.end(); ++it) {
        Total += *it;
    }
    </pre>
    <h5>C++11</h5>
    <pre class="brush: c++">
    // Preferred, constant reference
    for(const auto &Value : Container) {
        Total += Value;
    }

    // Work on copy
    for(auto Value : Container) {
        Total += Value;
    }

    // Work on reference, modify in-place
    for(auto &Value : Container) {
        Value += 2.0;
    }
    </pre>
</section>

<section class="slide">
    <h2>Enum class - scoped and strongly typed enums</h2>
    <pre class="brush: c++">
        enum Alert { green, yellow, orange, red }; // traditional enum

        enum class Color { red, blue };   // scoped and strongly typed enum
                                          // no export of enumerator names into enclosing scope
                                          // no implicit conversion to int
        enum class TrafficLight { red, yellow, green };

        Alert a = 7;              // error (as ever in C++)
        Color c = 7;              // error: no int->Color conversion

        int a2 = red;             // ok: Alert->int conversion
        int a3 = Alert::red;      // error in C++98; ok in C++11
        int a4 = blue;            // error: blue not in scope
        int a5 = Color::blue;     // error: not Color->int conversion

        Color a6 = Color::blue;   // ok

    </pre>
    
    <h5><a href="http://www.stroustrup.com/C++11FAQ.html#enum">Source</a></h5>
</section>

<section class="slide">
    <h2>Delegating constructor</h2>
    <table style="width: 100%">
        <colgroup>
            <col width="50%" /><col width="50%" />
        </colgroup>
        <tr>
        <td valign="top">
            <pre class="brush: c++">
            class A{
            public:
                A():
                num1(0),
                num2(0) {
                   init();
                }
                
                A(int i):
                num1(i),
                num2(0) {
                    init();
                }
                
                A(int i, int j):
                num1(i),
                num2(j) {
                    init();
                }
            private:
                int num1;
                int num2;
                int average;
                void init() { average = (num1+num2) / 2; };
            };

            </pre>
        </td>
        <td valign="top"><!-- Other input -->
            <pre class="brush: c++">
            class A{
            public:    
               A():
                 A(0) { }
               A(int i):
                 A(i, 0) { }
               A(int i, int j) : num1(i), num2(j) {
                  average = (num1+num2) / 2;
               }
            private:
               const int num1;
               const int num2;
               int average;
            };

            </pre>
            <h5><a href="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/introduction_to_the_c_11_feature_delegating_constructors?lang=en">Source</a></h5>
        </td>
    </table>
</section>

<section class="slide">
    <h2>final</h2>
    <pre class="brush: c++">
    struct A
    {
        virtual void foo() final; // A::foo is final
        void bar() final; // Error: non-virtual function cannot be final
    };
     
    struct B final : A // struct B is final
    {
        void foo(); // Error: foo cannot be overridden as it's final in A
    };
     
    struct C : B // Error: B is final
    {
    };
    </pre>
    <ul>
        <li><a href="http://en.cppreference.com/w/cpp/language/final">Source</a></li>
    </ul>
</section>

<section class="slide">
    <h2>override</h2>
    <pre class="brush: c++">
    struct A
    {
        virtual void foo();
        void bar();
    };
     
    struct B : A
    {
        void foo() const override; // Error: B::foo does not override A::foo
                                   // (signature mismatch)
        void foo() override; // OK: B::foo overrides A::foo
        void bar() override; // Error: B::bar is not virtual
    };
    </pre>
    <ul>
        <li><a href="http://en.cppreference.com/w/cpp/language/override">Source</a></li>
    </ul>
</section>

<section class="slide">
    <h2>default & delete</h2>
    <h5>Deleting methods</h5>
    <pre class="brush: c++">
    // C++11 version of noncopyable
    struct noncopyable
    {
      noncopyable() = default;
      noncopyable(const noncopyable&) = delete;
      noncopyable& operator=(const noncopyable&) = delete;
    };
    </pre>
    <h5><i>Explicit</i> defaults</h5>
    <pre class="brush: c++">
    struct widget
    {
      widget() = default;

      inline widget& operator = (const widget&);
    };

    inline widget& widget::operator=(const widget&) = default;
    </pre>

    <ul>
        <li><a href="http://msdn.microsoft.com/en-us/library/dn457344.aspx">Source</a></li>
    </ul>
</section>

<section class="slide">
<h2>New algorithms</h2>
    <ul>
        <li>all_of, any_of, none_of, find_if_not, copy_if, copy_n</li>
        <li>uninitialized_copy_n, move, move_backward, is_partitioned, partition_copy, partition_point etc...</li>
    </ul>
<pre class="brush: c++">
    std::vector&lt;std::string&gt; Container1 = { "banana", "apple", "orange", "ananas" };

    assert(std::all_of(Container1.begin(), Container1.end(),
        [](std::string Value) { return Value != "pineapple"; }));

    assert(std::any_of(Container1.begin(), Container1.end(),
        [](std::string Value) { return Value == "orange"; }));

    assert(std::none_of(Container1.begin(), Container1.end(),
        [](std::string Value) { return Value == "pineapple"; }));
</pre>
    <ul>
        <li>See <a href="http://www.cplusplus.com/reference/algorithm/">&lt;algorithm&gt;</a> reference</li>
    </ul>
</section>

<!-- next slide -->
<section class="slide">
                
    <h1>More about modern C++
    <ul>
        <li style="font-size:large">Supported in Visual Studio 2010, Visual Studio 2012</li>
    </ul></h1>
</section>

<!-- next slide -->
<section class="slide">
    <h2>auto</h2>
    <h5>C++98</h5>
    <pre class="brush: c++">
        map&lt;int,string&gt;::iterator i = m.begin();
        double const xlimit = config["xlimit"];
        singleton& s = singleton::instance();
        binder2nd< greater > x = bind2nd( greater(), 42 );
    </pre>
    <h5>C++11</h5>
    <pre class="brush: c++">
        auto i = begin(m);
        auto const xlimit = config["xlimit"];
        auto& s = singleton::instance();
        auto x = [](int i) { return i > 42; };
    </pre>
    <a href="http://herbsutter.com/elements-of-modern-c-style/">Source</a>

</section>

<!-- next slide -->
<section class="slide">
    <h2>Pointer usage</h2>
    <h5>Do not use pointers, allocate on stack</h5>
    <p></p>
    <h5>If you <em>absolutely</em> have to, the preferred order is:</h5>
    <ol>
        <li>Stack allocation</li>
        <li><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a></li>
        <li><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a></li>
        <li>(<a href="http://www.boost.org/doc/libs/1_55_0/libs/smart_ptr/intrusive_ptr.html">boost::intrusive_ptr</a>)</li>
        <li>Framework specific pointer classes</li>
        <li>Never use: Raw pointers</li>
    </ol>
</section>

<!-- next slide -->
<section class="slide">
    <h2>Pointer usage</h2>
    <h5>Do this</h5>
    <pre class="brush: c++">
        std::string MyString("foo bar baz");
        const extrema_t Extrema = { Vector_c(-1800.0, -500.0, -250.0),
                                    Vector_c( 1800.0,  500.0,  250.0) };
        
        // if you absolutely have to
        auto StringPtr = std::unique_ptr&lt;std::string&gt;("foo bar baz");
        auto ExtremaPtr = std::make_unique&lt;extrema_t&gt; (extrema_t{ Vector_c(-1800.0, -500.0, -250.0),
                                                                  Vector_c( 1800.0,  500.0,  250.0) });
    </pre>
    <h5>Get a team architect approval for doing this</h5>
    <pre class="brush: c++">
        auto pMyString = std::make_shared&lt;std::string&gt;("foo bar baz");
    </pre>
    <h5>Never do this</h5>
    <pre class="brush: c++">        
        std::string *pMyString = new std::string("foo bar baz");
    </pre>
</section>

<!-- next slide -->
<section class="slide">
    <h2>String to int, String to double conversion</h2>
    <h5>Locale makes a difference</h5>
    <pre class="brush: c++">
    std::locale::global(std::locale("finnish"));

    assert(std::stoi("100,200") == 100);
    assert(std::stoi("100.200") == 100);
    assert(std::stoi("100 200") == 100.0);

    assert(std::stod("100,200") == 100.200);
    assert(std::stod("100.200") == 100.0);
    assert(std::stod("100 200") == 100.0);

    std::locale::global(std::locale("japanese"));

    assert(std::stoi("100,200") == 100);
    assert(std::stoi("100.200") == 100);
    assert(std::stoi("100 200") == 100.0);

    assert(std::stod("100,200") == 100.0); // difference
    assert(std::stod("100.200") == 100.200); // difference
    assert(std::stod("100 200") == 100.0);
    </pre>
</section>

<!-- next slide -->
<section class="slide">
    <h2>Number to string conversion</h2>
    <h5>Locale makes a difference</h5>
    <pre class="brush: c++">
    std::locale::global(std::locale("finnish"));

    assert(std::to_string(1000.200) == "1 000,200000"); // difference
    assert(std::to_string(100) == "100");

    std::locale::global(std::locale("japanese"));

    assert(std::to_string(1000.200) == "1,000.200000"); // difference
    assert(std::to_string(100) == "100");
    </pre>
</section>

<!-- next slide -->
<section class="slide">
    <img src="img/STLcontainerChoices.png" alt="" />
    <p>Selecting a C++ container. <a href="http://www.cim.mcgill.ca/~mpersson/cxx_diagrams.html">Source</a></p>
</section>
    
<section class="slide">
    <h2>Questions & discussion</h2>
</section>
        
        <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
        <a href="#" class="deck-next-link" title="Next">&#8594;</a>
        
        <p class="deck-status">
            <span class="deck-status-current"></span>/<span class="deck-status-total"></span>
        </p>
        
        <form action="." method="get" class="goto-form">
            <label for="goto-slide">Go to slide:</label>
            <input type="number" name="slidenum" id="goto-slide">
            <input type="submit" value="Go">
        </form>
        
        <a href="." title="Permalink to this slide" class="deck-permalink">#</a>
        
        <script src="js/jquery-1.7.2.min.js"></script>
        <script>window.jQuery</script>
        
        <script type="text/javascript" src="js/syntaxhighlighter_3.0.83/scripts/shCore.js"></script>
        <script type="text/javascript" src="js/syntaxhighlighter_3.0.83/scripts/shBrushJScript.js"></script>
        <script type="text/javascript" src="js/syntaxhighlighter_3.0.83/scripts/shBrushCpp.js"></script>        
        <script type="text/javascript">SyntaxHighlighter.all();</script>
        
        <!-- Deck Core and extensions -->
        <script src="js/deck.core.js"></script>
        <script src="js/deck.menu.js"></script>
        <script src="js/deck.goto.js"></script>
        <script src="js/deck.status.js"></script>
        <script src="js/deck.navigation.js"></script>
        <script src="js/deck.hash.js"></script>
        
        <script type="text/javascript">        
            $(function() {
                // Deck initialization
                $.deck('.slide');
                $('#style-themes').change(function() {
                    $('#style-theme-link').attr('href', $(this).val());
                });
                $('#transition-themes').change(function() {
                    $('#transition-theme-link').attr('href', $(this).val());
                });
                $('pre').click(function (){
                    $(this).toggleClass('highlighted');
                });
            });
        </script>
    </body>
</html>
