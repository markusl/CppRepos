<!DOCTYPE html>
<html class="no-js" lang="en"> 
    <head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<title>C++11 new features</title>    
	<meta name="description" content="">
	<meta name="viewport" content="width=1024, user-scalable=no">

	<!-- Core and extension CSS files -->
	<link rel="stylesheet" href="css/deck.core.css">
	<link rel="stylesheet" href="css/deck.goto.css">
	<link rel="stylesheet" href="css/deck.menu.css">
	<link rel="stylesheet" href="css/deck.navigation.css">
	<link rel="stylesheet" href="css/deck.status.css">
	<link rel="stylesheet" href="css/deck.hash.css">
	
	<link href="js/css" rel="stylesheet" type="text/css.css">        
	<link href="js/css(1)" rel="stylesheet" type="text/css">

	<!-- Theme CSS files -->
	<link rel="stylesheet" id="style-theme-link" href="css/swiss.css">
	<link rel="stylesheet" id="transition-theme-link" href="css/horizontal-slide.css">
	
	<script src="js/modernizr.custom.js"></script><style type="text/css"></style>
	<link type="text/css" rel="stylesheet" href="css/shCoreDefault.css">
	
	<!-- Custom CSS just for this page -->        
	<link rel="stylesheet" href="css/tekla.css"> 
</head>
<body class="deck-container">

<section class="slide">
	<h1>C++11 new features</h1>
	<div class="title-page">
		<p></p>
		<table width="100%">
		  <colgroup>
			<col width="1*">
			<col width="1*">
		  </colgroup>
		<tbody>
			<tr><td>
			Markus Lindqvist<br>
			19.3.2014<br>
			<a href="http://tekla.com">Tekla</a></td>
			<td><p align="right">
			markus.lindqvist@tekla.com<br>
			</p></td></tr>
			</tbody>
		</table>
	</div>
</section>

<section class="slide">
	<h2>Content</h2>
	<ul>
		<li><h5>Introduction to C++ history</h5></li>
	</ul>
	<ul>
		<li><h5>New features of C++11</h5>
			<ul>
				<li>Uniform initialization</li>
				<li>Range-based for</li>
				<li>Enum class</li>
				<li>Delegating constructor</li>
				<li>STL algorithms</li>
				<li>Other cool features!</li>
			</ul>
		</li>
		<li><h5>Modern C++</h5>
			<ul>
				<li>auto</li>
				<li>range-based for</li>
				<li>Pointer usage</li>
				<li>Algorithm usage</li>
			</ul>
		</li>
	</ul>
</section>

<!-- next slide -->
<section class="slide">
	<h2>C++ history</h2>
	<table style="width: 100%">
		<colgroup>
			<col width="50%" /><col width="50%" />
		</colgroup>
		<tr>
		<td valign="top"><!-- Other input -->
			<ul>
				<li>1979 - "C with Classes"</li>
				<li>1983 - Language named to "C++"</li>
				<li>1998 - C++98 (ISO/IEC 14882:1998)</li>
				<li>2003 - C++03 (ISO/IEC 14882:2003)</li>
				<li>2007 - C++TR1 (ISO/IEC TR 19768:2007)</li>
				<li><strong>2011 - C++11 (ISO/IEC 14882:2011)</strong></li>
				<li>201x - C++14</li>
				<li>201x - C++17</li>
			</ul>
		</td>
		<td valign="top"><!-- Other input -->
			<img src="img/cpp_evolution.jpg" alt="" />
		</td>
	</table>
    <a href="http://isocpp.org/std/status">http://isocpp.org/std/status</a>
</section>

<!-- next slide -->
<section class="slide">
	<h2>Visual Studio C++11/C++14 support</h2>
	<img src="img/Updated_Conformance_Map.png" alt="" />
    <a href="http://blogs.msdn.com/b/vcblog/archive/2013/11/18/announcing-the-visual-c-compiler-november-2013-ctp.aspx">Announcing the Visual C++ Compiler November 2013 CTP</a>
</section>

<!-- next slide -->
<section class="slide">
	<h2>Range-based for loop</h2>
	<h5>C++98</h5>
	<pre class="brush: c++">
	for(vector&lt;int>::iterator it = Container.begin(); it != Container.end(); ++it) {
	    Total += *it;
	}
	</pre>
	<h5>C++11</h5>
	<pre class="brush: c++">
	// Preferred, constant reference
	for(const auto &Value : Container) {
	    Total += Value;
	}

	// Work on copy
	for(auto Value : Container) {
	    Total += Value;
	}

	// Work on reference, modify in-place
	for(auto &Value : Container) {
	    Value += 2.0;
	}
	</pre>
</section>

<section class="slide">
	<h2>Enum class - scoped and strongly typed enums</h2>
	<pre class="brush: c++">
		enum Alert { green, yellow, orange, red }; // traditional enum

		enum class Color { red, blue };   // scoped and strongly typed enum
										  // no export of enumerator names into enclosing scope
										  // no implicit conversion to int
		enum class TrafficLight { red, yellow, green };

		Alert a = 7;              // error (as ever in C++)
		Color c = 7;              // error: no int->Color conversion

		int a2 = red;             // ok: Alert->int conversion
		int a3 = Alert::red;      // error in C++98; ok in C++11
		int a4 = blue;            // error: blue not in scope
		int a5 = Color::blue;     // error: not Color->int conversion

		Color a6 = Color::blue;   // ok

	</pre>
	
	<h5><a href="http://www.stroustrup.com/C++11FAQ.html#enum">Source</a></h5>
</section>

<section class="slide">
	<h2>Delegating constructor</h2>
	<table style="width: 100%">
		<colgroup>
			<col width="50%" /><col width="50%" />
		</colgroup>
		<tr>
		<td valign="top">
            <pre class="brush: c++">
            class A{
            public:
                A():
                num1(0),
                num2(0) {
                   init();
                }
                
                A(int i):
                num1(i),
                num2(0) {
                    init();
                }
                
                A(int i, int j):
                num1(i),
                num2(j) {
                    init();
                }
            private:
                int num1;
                int num2;
                int average;
                void init() { average = (num1+num2) / 2; };
            };

            </pre>
        </td>
        <td valign="top"><!-- Other input -->
            <pre class="brush: c++">
            class A{
            public:    
               A():
                 A(0) { }
               A(int i):
                 A(i, 0) { }
               A(int i, int j) {
                  num1 = i;
                  num2 = j;
                  average = (num1+num2) / 2;
               }
            private:
               int num1;
               int num2;
               int average;
            };

            </pre>
            <h5><a href="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/introduction_to_the_c_11_feature_delegating_constructors?lang=en">Source</a></h5>
		</td>
	</table>
</section>

<section class="slide">
	<h2>final</h2>
    <pre class="brush: c++">
    struct A
    {
        virtual void foo() final; // A::foo is final
        void bar() final; // Error: non-virtual function cannot be final
    };
     
    struct B final : A // struct B is final
    {
        void foo(); // Error: foo cannot be overridden as it's final in A
    };
     
    struct C : B // Error: B is final
    {
    };
    </pre>
	<ul>
		<li><a href="http://en.cppreference.com/w/cpp/language/final">Source</li>
	</ul>
</section>

<section class="slide">
	<h2>override</h2>
    <pre class="brush: c++">
    struct A
    {
        virtual void foo();
        void bar();
    };
     
    struct B : A
    {
        void foo() const override; // Error: B::foo does not override A::foo
                                   // (signature mismatch)
        void foo() override; // OK: B::foo overrides A::foo
        void bar() override; // Error: B::bar is not virtual
    };
    </pre>
	<ul>
		<li><a href="http://en.cppreference.com/w/cpp/language/override">Source</a></li>
	</ul>
</section>

<section class="slide">
	<h2>default & delete</h2>
    <h5>Deleting methods</h5>
    <pre class="brush: c++">
    // C++11 version of noncopyable
    struct noncopyable
    {
      noncopyable() = default;
      noncopyable(const noncopyable&) = delete;
      noncopyable& operator=(const noncopyable&) = delete;
    };
    </pre>
    <h5><i>Explicit</i> defaults</h5>
    <pre class="brush: c++">
    struct widget
    {
      widget() = default;

      inline widget& operator = (const widget&);
    };

    inline widget& widget::operator=(const widget&) = default;
    </pre>

	<ul>
		<li><a href="http://msdn.microsoft.com/en-us/library/dn457344.aspx">Source</li>
	</ul>
</section>

<section class="slide">
<h2>New algorithms</h2>
	<ul>
		<li>all_of, any_of, none_of, find_if_not, copy_if, copy_n</li>
        <li>uninitialized_copy_n, move, move_backward, is_partitioned, partition_copy, partition_point etc...</li>
	</ul>
<pre class="brush: c++">
    std::vector&lt;std::string> Container1 = { "banana", "apple", "orange", "ananas" };

    assert(std::all_of(Container1.begin(), Container1.end(),
        [](std::string Value) { return Value != "pineapple"; }));

    assert(std::any_of(Container1.begin(), Container1.end(),
        [](std::string Value) { return Value == "orange"; }));

    assert(std::none_of(Container1.begin(), Container1.end(),
        [](std::string Value) { return Value == "pineapple"; }));
</pre>
	<ul>
		<li>See <a href="http://www.cplusplus.com/reference/algorithm/">&lt;algorithm></a> reference</li>
	</ul>
</section>

<!-- next slide -->
<section class="slide">
<h2>auto</h2>
<h5>C++98</h5>
<pre class="brush: c++">
map&lt;int,string>::iterator i = m.begin();
double const xlimit = config["xlimit"];
singleton& s = singleton::instance();
binder2nd< greater > x = bind2nd( greater(), 42 );
</pre>
<h5>C++11</h5>
<pre class="brush: c++">
auto i = begin(m);
auto const xlimit = config["xlimit"];
auto& s = singleton::instance();
auto x = [](int i) { return i > 42; };
</pre>
<a href="http://herbsutter.com/elements-of-modern-c-style/">Source</a>

</section>

<section class="slide">
	<h2>Questions & discussion</h2>
</section>
        
        <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
        <a href="#" class="deck-next-link" title="Next">&#8594;</a>
        
        <p class="deck-status">
            <span class="deck-status-current"></span>/<span class="deck-status-total"></span>
        </p>
        
        <form action="." method="get" class="goto-form">
            <label for="goto-slide">Go to slide:</label>
            <input type="number" name="slidenum" id="goto-slide">
            <input type="submit" value="Go">
        </form>
        
        <a href="." title="Permalink to this slide" class="deck-permalink">#</a>
        
        <script src="js/jquery-1.7.2.min.js"></script>
        <script>window.jQuery</script>
        
        <script type="text/javascript" src="js/syntaxhighlighter_3.0.83/scripts/shCore.js"></script>
        <script type="text/javascript" src="js/syntaxhighlighter_3.0.83/scripts/shBrushJScript.js"></script>
        <script type="text/javascript" src="js/syntaxhighlighter_3.0.83/scripts/shBrushCpp.js"></script>        
        <script type="text/javascript">SyntaxHighlighter.all();</script>
        
        <!-- Deck Core and extensions -->
        <script src="js/deck.core.js"></script>
        <script src="js/deck.menu.js"></script>
        <script src="js/deck.goto.js"></script>
        <script src="js/deck.status.js"></script>
        <script src="js/deck.navigation.js"></script>
        <script src="js/deck.hash.js"></script>
        
        <script type="text/javascript">        
            $(function() {
                // Deck initialization
                $.deck('.slide');
                $('#style-themes').change(function() {
                    $('#style-theme-link').attr('href', $(this).val());
                });
                $('#transition-themes').change(function() {
                    $('#transition-theme-link').attr('href', $(this).val());
                });
                $('pre').click(function (){
                    $(this).toggleClass('highlighted');
                });
            });
        </script>
	</body>
</html>